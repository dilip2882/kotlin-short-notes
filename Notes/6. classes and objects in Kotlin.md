**Defining a Class in Kotlin**

When defining a class in Kotlin, you specify the properties and methods that all objects of that class should have. Here are the main points:

1. **Class Definition:**
   - A class definition starts with the `class` keyword, followed by a name and a set of curly braces.
   - The class header specifies the class name, and the curly braces contain the class body.
   - Recommended naming conventions:
     - Choose any class name (avoid using Kotlin keywords).
     - Use PascalCase (capitalize each word) without spaces (e.g., `SmartDevice`).

2. **Class Components:**
   - Properties: Variables that specify the attributes of the class's objects.
   - Methods: Functions that define the class's behaviors and actions.
   - Constructors: Special member functions that create instances of the class.

3. **Example: Defining a SmartDevice Class:**
   ```kotlin
   class SmartDevice {
       // Empty body (properties and methods can be added here)
   }
   ```

# Create an Instance of a Class

To create an actual object of a class, you need to instantiate it. Here are the main points:

**Instantiation Syntax:**
   - To create an object, use the class name followed by parentheses.
   - Assign the object to a variable using the `val` or `var` keyword.
   - Example:
     ```kotlin
     val smartTvDevice = SmartDevice()
     ```

Remember that the variable referencing the object is read-only (using `val`), but the class object itself remains mutable. You can update its properties' values even though you can't reassign another object to the same variable.

# Defining Class Methods in Kotlin

When defining a class, you can include methods (functions) that represent the behavior of the class. Here are the main points:

1. **Method Definition:**
   - Methods in a class are referred to as member functions.
   - They are defined within the class body.
   - Syntax:
     ```kotlin
     class SmartDevice {
         fun turnOn() {
             // Method body
             println("Smart device is turned on.")
         }

         fun turnOff() {
             // Method body
             println("Smart device is turned off.")
         }
     }
     ```

2. **Calling Class Methods:**
   - To call a method on an object, use the object followed by the `.`, the method name, and parentheses.
   - Example:
     ```kotlin
     val smartTvDevice = SmartDevice()
     smartTvDevice.turnOn()
     smartTvDevice.turnOff()
     ```
# Defining Class Properties in Kotlin

When defining a class, you can include properties (variables) that represent the characteristics or data attributes of the class. Here are the main points:

1. **Property Definition:**
   - Properties are defined within the class body.
   - Use the `val` keyword for read-only properties and the `var` keyword for mutable properties.
   - Example:
     ```kotlin
     class SmartDevice {
         val name = "Android TV"
         val category = "Entertainment"
         var deviceStatus = "online"
     }
     ```

2. **Getter and Setter Functions:**
   - When defining a mutable property, you can provide custom getter and setter functions.
   - The getter function retrieves the value of the property (autogenerated if not explicitly defined).
   - The setter function allows you to validate and modify the value being assigned (autogenerated if not explicitly defined).

3. **Example: Speaker Volume Property:**
   - To ensure that the speakerVolume property stays within a valid range (0 to 100), you can define custom getter and setter functions.
   - Example (autogenerated):
     ```kotlin
     var speakerVolume = 2
         get() = field
         set(value) {
             field = value.coerceIn(0, 100)
         }
     ```
# Defining Constructors in Kotlin

Constructors in Kotlin allow you to initialize objects of a class. Here are the main points:

1. **Default Constructor:**
   - A default constructor has no parameters and is autogenerated by the compiler.
   - You can omit the `constructor` keyword and parentheses if there are no annotations or visibility modifiers.
   - Example:
     ```kotlin
     class SmartDevice {
         // Default constructor (autogenerated)
         ...
     }
     ```

2. **Parameterized Constructor:**
   - A parameterized constructor accepts arguments to initialize properties.
   - Define it in the class header with the desired parameters.
   - Example:
     ```kotlin
     class SmartDevice(val name: String, val category: String) {
         var deviceStatus = "online"
         ...
     }
     ```

3. **Named Arguments for Clarity:**
   - When instantiating an object, use named arguments for clarity:
     ```kotlin
     val smartTvDevice = SmartDevice(name = "Android TV", category = "Entertainment")
     ```
# Implementing Class Inheritance in Kotlin

Inheritance allows you to build a class based on the characteristics and behavior of another class.

1. **Class Hierarchy:**
   - Inheritance establishes relationships between classes.
   - A superclass (parent class) can be extended by one or more subclasses (child classes).
   - Subclasses inherit properties and methods from the superclass.

2. **Creating a Superclass:**
   - Define a superclass (e.g., `SmartDevice`) with common properties and behaviors.
   - Use the `open` keyword to make the superclass extendable.
   - Example:
     ```kotlin
     open class SmartDevice(val name: String, val category: String) {
         // Common properties and methods
     }
     ```

3. **Creating Subclasses:**
   - Define subclasses (e.g., `SmartTvDevice`, `SmartLightDevice`) that extend the superclass.
   - Use the superclass constructor in the subclass header.
   - Add additional properties and methods specific to each subclass.
   - Example:
     ```kotlin
     class SmartTvDevice(deviceName: String, deviceCategory: String) :
         SmartDevice(name = deviceName, category = deviceCategory) {
         var speakerVolume = 2
         // Additional properties and methods
     }
     ```

**Relationships Between Classes in Kotlin**

In object-oriented programming, relationships between classes can be established through inheritance and composition. Here are the main points:

1. **IS-A Relationship (Inheritance):**
   - An IS-A relationship represents inheritance.
   - A subclass (child class) extends a superclass (parent class).
   - Example:
     ```kotlin
     // Smart TV IS-A smart device.
     class SmartTvDevice : SmartDevice() {
         // Additional properties and methods
     }
     ```

2. **HAS-A Relationship (Composition):**
   - A HAS-A relationship represents composition.
   - A class contains an instance of another class.
   - Example:
     ```kotlin
     // The SmartHome class HAS-A smart TV device.
     class SmartHome(val smartTvDevice: SmartTvDevice) {
         // Methods to interact with the smart TV
     }
     ```

3. **Considerations:**
   - Choose the appropriate relationship based on the nature of the classes.
   - IS-A relationships imply that a subclass is a superclass.
   - HAS-A relationships imply that one class contains or owns another class.

**Overriding Superclass Methods in Kotlin**

When working with inheritance, you can override methods defined in the superclass to provide custom behavior in subclasses. Here are the main points:

1. **Method Overriding:**
   - To override a method in a subclass, use the `override` keyword before the method definition.
   - The overridden method in the subclass replaces the implementation of the same method in the superclass.
   - Example (SmartLightDevice overriding SmartDevice methods):
     ```kotlin
     open class SmartDevice(val name: String, val category: String) {
         open fun turnOn() { /* Default implementation */ }
         open fun turnOff() { /* Default implementation */ }
     }

     class SmartLightDevice(deviceName: String, deviceCategory: String) :
         SmartDevice(name = deviceName, category = deviceCategory) {
         var brightnessLevel = 0
         override fun turnOn() {
             deviceStatus = "on"
             brightnessLevel = 2
             println("$name turned on. The brightness level is $brightnessLevel.")
         }
         override fun turnOff() {
             deviceStatus = "off"
             brightnessLevel = 0
             println("Smart Light turned off")
         }
     }
     ```

2. **Custom Behavior:**
   - Override methods to provide device-specific behavior while maintaining the common interface defined in the superclass.
   - Customize the method implementation in the subclass according to the specific requirements.

# Visibility Modifiers in Kotlin

Visibility modifiers control the accessibility of properties and methods in classes. Here are the main points:

1. **Visibility Levels:**
   - `public`: Default visibility modifier. Accessible everywhere.
   - `private`: Accessible only within the same class or source file.
   - `protected`: Accessible in subclasses.
   - `internal`: Accessible within the same module.

2. **Use Cases:**
   - Use `private` for properties and methods that should not be accessed outside the class.
   - Use `protected` for properties and methods used within the class and its subclasses.
   - Use `internal` for properties and methods accessible within the same module.

3. **Example:**
   ```kotlin
   open class SmartDevice(val name: String, val category: String) {
       private var deviceStatus = "online"
       ...
   }
   ```

4. **Method Visibility:**
   - Specify visibility for methods using `private`, `protected`, `internal`, or `public` modifiers.
   - Example (protected method in SmartTvDevice):
     ```kotlin
     class SmartTvDevice(deviceName: String, deviceCategory: String) :
         SmartDevice(name = deviceName, category = deviceCategory) {
         protected fun nextChannel() {
             channelNumber++
             println("Channel number increased to $channelNumber.")
         }
         ...
     }
     ```

5. **Constructor Visibility:**
   - Specify visibility for constructors by placing the modifier after the class name.
   - Example (protected constructor in SmartDevice):
     ```kotlin
     open class SmartDevice protected constructor(val name: String, val category: String) {
         ...
     }
     ```

6. **Class Visibility:**
   - Specify visibility for classes using `private`, `protected`, `internal`, or `public` modifiers.
   - Example (internal class SmartDevice):
     ```kotlin
     internal open class SmartDevice(val name: String, val category: String) {
         ...
     }
     ```

# Property Delegates in Kotlin

Property delegates allow you to manage property values with custom logic. Here are the main points:

1. **Delegated Properties:**
   - Instead of using a backing field and getter/setter functions, you can delegate property management to a separate class.
   - Syntax: `val/var propertyName: PropertyType by delegateClass()`
   - Example (RangeRegulator delegate for var type):
     ```kotlin
     class RangeRegulator(
         initialValue: Int,
         private val minValue: Int,
         private val maxValue: Int
     ) : ReadWriteProperty<Any?, Int> {
         override fun getValue(thisRef: Any?, property: KProperty<*>): Int {
             // Custom getter logic
         }
         override fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {
             // Custom setter logic
         }
     }
     ```

2. **Interfaces and Abstraction:**
   - Interfaces define contracts for classes to implement.
   - Delegates can be implemented using interfaces (e.g., `ReadWriteProperty`).
   - Interfaces focus on what to do (abstraction) rather than how to do it.

3. **Usage:**
   - Create a delegate class that implements the desired interface.
   - Use the delegate class to manage property values.
   - Example: Delegate for `var` type properties with range regulation.

# Summary

OOP Principles:
- **Encapsulation**, **abstraction**, **inheritance**, and **polymorphism** are fundamental principles.

Class Basics:
- Classes are defined using the `class` keyword and contain properties and methods.
- Properties can have custom getters and setters.
- Constructors specify how to create class instances.
- The primary constructor can omit the `constructor` keyword.

Inheritance:
- Inheritance allows code reuse.
- The **IS-A** relationship refers to inheritance.
- The **HAS-A** relationship refers to composition.

Visibility Modifiers:
- Control access to properties and methods using visibility modifiers.
- Available modifiers: `public`, `private`, `protected`, and `internal`.

Property Delegates:
- Delegates manage property values with custom logic.
- Syntax: `val/var propertyName: PropertyType by delegateClass()`
